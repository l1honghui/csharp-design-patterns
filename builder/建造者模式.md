# 建造者模式
## 动机
> 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？

## 意图
>  将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 

## 建造者模式包含如下角色：
- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

## 结构图

	Director			=>		AbstractBuilder 

		↓							BuildPart()

	SetBuilder()					GetProduct() 

	Construct()				ConcreteBuilder		=>		Product 

	GetProduct()					BuildPart()

									GetProduct()
## 模式组成

  （1）、抽象建造者角色（Builder）：为创建一个Product对象的各个部件指定抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此角色规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。

  （2）、具体建造者（ConcreteBuilder）

     1）实现Builder的接口以构造和装配该产品的各个部件。即实现抽象建造者角色Builder的方法。

     2）定义并明确它所创建的表示，即针对不同的商业逻辑，具体化复杂对象的各部分的创建

     3) 提供一个检索产品的接口

     4) 构造一个使用Builder接口的对象即在指导者的调用下创建产品实例

  （3）、指导者（Director）：调用具体建造者角色以创建产品对象的各个部分。指导者并没有涉及具体产品类的信息，真正拥有具体产品的信息是具体建造者对象。它只负责保证对象各部分完整创建或按某种顺序创建。

  （4）、产品角色（Product）：建造中的复杂对象。它要包含那些定义组件的类，包括将这些组件装配成产品的接口。

## 总结
### 优点
1. 使用建造者模式可以使客户端不必知道产品内部组成的细节。
2. 具体的建造者类之间是相互独立的，容易扩展。
3. 由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

### 缺点
1. 产生大量的Build和Director类

### 使用场景

1. 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
2. 相同的方法，不同的执行顺序，产生不同的事件结果时。
3. 多个部件或零件,都可以装配到一个对象中，但是产生的运行结果又不相同时。
4. 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。
5. 创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。

## 案例
StringBuilder