# 原型模式
## 动机
>   在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户程序”不随着需求改变而改变

## 意图
>  使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

## 建造者模式包含如下角色：
1. 原型类（Prototype）：原型类，声明一个Clone自身的接口；
2. 具体原型类（ConcretePrototype）：实现一个Clone自身的操作。

## 总结
### 优点
优点：

1.原型模式向客户隐藏了创建新实例的复杂性

2.原型模式允许动态增加或较少产品类。

3.原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。

4.产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构

### 使用的场景：

1.资源优化场景

> 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。

2.性能和安全要求的场景

> 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

3.一个对象多个修改者的场景

> 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。
在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。

## 案例
> 在.NET中，微软已经为我们提供了原型模式的接口实现，该接口就是ICloneable，其实这个接口就是抽象原型，提供克隆方法，相当于与上面代码中Prototype抽象类，其中的Clone()方法来实现原型模式，如果我们想我们自定义的类具有克隆的功能，首先定义类实现ICloneable接口的Clone方法。